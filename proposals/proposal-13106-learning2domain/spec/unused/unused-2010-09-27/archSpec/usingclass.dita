<?xml version="1.0" encoding="utf-8"?>
<!--Arbortext, Inc., 1988-2004, v.4002-->
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<?Pub Inc?>
<concept id="usingclass" xml:lang="en-us">
<title>Using the class attribute</title>
<shortdesc>By basing an XSLT template on class attribute values, a   transform can be applied to  families of element types (specialization branches) rather than only to single element types.</shortdesc>
<conbody>
<p>If an XPath statement that  contains
an element name encounters an unknown element, it can check the value
of that element's architectural class attribute. The class attribute identifies an ancestor element, or a sequence of ancestor elements, from which the given element is specialized. (It therefore defines a class of all elements with the same specialization ancestry, hence the name of the attribute.) The transform can safely  treat the unknown element according to the rules
for a known element that is specified in the value of the class attribute.</p>
<p> The class attribute
 string check must include a leading and trailing space to avoid false matches. For example, without the spaces,
 'task/step' would match on both 'task/step' and on 'notatask/stepaway'.</p><p>The modular design of DITA lends itself to creating a shell file into which modules of XSL code are imported. Import precedence then permits special provisions  to override more general ones in a flexible way that supports future growth and change. If a transform targets more than one type,
the more specific rules must have a higher precedence than the more generic rules.
For example, to combine the existing processing rules for topics with
more specific processing rules for tasks, import precedence can  ensure that task-specific rules override generic rules for topics where that is desired. Other techniques for establishing precedence are not as flexible and can result in conflicts.</p>

<example id="example_00CE34EF7A0D4FAC90F6E54CFA8AA5BA"><title>Example: match statement for list items</title><codeblock>&lt;xsl:template match="li"&gt;</codeblock><p>becomes</p><codeblock>&lt;xsl:template match="*[contains(@class,' topic/li ')]"&gt;</codeblock><p>This match statement not only works on any &lt;li&gt; element that it encounters, it
 also works on elements specialized from &lt;li&gt;, such as the &lt;step&gt; and &lt;appstep&gt; elements. Such elements do not have to be identified specifically, because the class attribute identifies the class to which they belong. If another statement with higher precedence matches the &lt;step&gt; or &lt;appstep&gt; element (such as that in the next example), the above statement is ignored. If no other statement with higher precedence matches the &lt;step&gt; or &lt;appstep&gt; element, this statement matches all elements in the class, as well as the more general &lt;li&gt; element from which they are specialized, so that the more specialized element is treated as though it were the &lt;li&gt; element.</p></example>
<example id="example_B031981CCB094910A12C491E71950AA1"><title>Example: match statement for steps</title><codeblock>&lt;xsl:template match="*[contains(@class,' task/step ')]"&gt;</codeblock><p>This
match statement does not work on generic &lt;li&gt; elements (which are defined in &lt;topic&gt;), but it does work  on both
the &lt;step&gt; element  (which is specialized from &lt;li&gt; in &lt;task&gt;) and the &lt;appstep&gt; element (which is specialized from &lt;step&gt;). If no other statement with higher precedence matches &lt;appstep&gt;, this one will treat it like a &lt;step&gt; element.</p></example>
</conbody>
</concept>
<?Pub *0000002412?>
