<?xml version="1.0" encoding="utf-8"?>
<!--Arbortext, Inc., 1988-2005, v.4002-->
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN"
 "concept.dtd">
<concept id="classattdef" xml:lang="en-us">
 <title>Class attribute syntax</title>
 <shortdesc>The class attribute has a particular syntax that must be followed for it to be processed
  correctly.</shortdesc>
 <conbody>
  <p><draft-comment author="Gershon">Need to merge this topic into "The class attribute" topic and
    then delete this from the map.</draft-comment>Every element must have a class attribute. The
   class attribute starts with a "-" if it is declared in a structural module, or a "+" if it is
   declared in a domain module. After the starting token are one or more blank-delimited values,
   ending with a blank. Each value has two parts: the first part identifies a specialization module,
   for example a topic type or domain name, and the second part (after a / ) identifies an element
   type. Structural names are taken from the root element for the topic type or map type. Domain
   names are defined in the domain module.<draft-comment>MP: per Eliot Kimber issue 2007/01/27,
    revised syntax description to change "package" to "module"</draft-comment></p>
  <p>Typically, the class attribute value should be declared as a default attribute value in the DTD
   or schema rather than directly in the document instance. The class attribute should not be
   modified by the author. </p>
  <p>
   <fig>
    <title>Example structural type element with class attribute</title>
    <codeblock>&lt;appstep class="- topic/li task/step bctask/appstep ">A specialized step&lt;/appstep></codeblock>
   </fig>
   <fig>
    <title>Example domain element with class attribute</title>
    <codeblock>&lt;wintitle class="+ topic/keyword ui-d/wintitle ">A specialized keyword&lt;/wintitle></codeblock>
   </fig>
  </p>
  <p>When the class attribute is declared in the DTD or schema, it must be declared with a default
   value. In order to support generalization round-tripping (generalizing specialized content into a
   generic form and then returning it to the specialized form) the default value must not be fixed.
   This allows the generalization process to overwrite the default values in a general document type
   with specialized values taken from the document being generalized.</p>
  <p>When a specialized type declares new elements, it must provide a class attribute for the new
   element. The class attribute must include a mapping for every structural type or domain in the
   specialized type's ancestry, even those in which no element renaming occurred. The mapping should
   start with the value for the base type (for example topic or map), and finish with the current
   element type. <fig>
    <title>Example attribute with intermediate value</title>
    <codeblock>&lt;windowname class="- topic/kwd task/<b>kwd</b> guitask/windowname "></codeblock>
   </fig>Intermediate values are necessary so that generalizing and specializing transforms can map
   values simply and accurately. For example, if task/kwd was missing as a value, and a user decided
   to generalize this guitask up to a task topic, then the transform would have to guess whether to
   map to kwd (appropriate if task is more general than guitask, which it is) or leave as windowname
   (appropriate if task were more specialized, which it isn't). By always providing mappings for
   more general values, we can then apply the simple rule that missing mappings must by default be
   to more specialized values than the one we are generalizing to, which means the last value in the
   list is appropriate. For example, when specializing to &lt;task>, if a &lt;p> element has no
   target value for &lt;task>, we can safely assume that &lt;p> does not specialize from &lt;task>
   and should not be generalized.</p>
  <p>While this example is trivial, more complicated hierarchies (say, five levels deep, with
   renaming occurring at two and four only) make explicit intermediate values essential.</p>
  <p>A specialized type does not need to change the class attribute for elements that it does not
   specialize, but simply reuses by reference from more generic levels. For example, since task,
   bctask, and guitask use the p element without specializing it, they don't need to declare
   mappings for it. </p>
  <p>A specialized type only declares class attributes for the elements that it uniquely declares.
   It does not need to declare class attributes for elements that it reuses or inherits.</p>
 </conbody>
</concept>
<?Pub Caret?>
<?Pub *0000004332?>
