<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dita PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<dita>
  <topic id="topic_aqh_5zt_3h">
    <title>Stage 3 proposal: Feature #13004</title>
    <shortdesc>Proposal to provide a mechanism for different effective key definitions at different
      locations within a map structure.</shortdesc>
    <body>
      <section>
        <title>Champion</title>
        <p>Chris Nitchie, Oberon Technologies, <xref href="mailto:chris.nitchie@oberontech.com"
            scope="external">chris.nitchie@oberontech.com</xref></p>
      </section>
      <section>
        <title>Tracking information</title>
        <simpletable frame="all" relcolwidth="1.0* 1.0* 1.0*">
          <sthead>
            <stentry>Event</stentry>
            <stentry>Date</stentry>
            <stentry>Links</stentry>
          </sthead>
          <strow>
            <stentry>Stage 1 proposal accepted</stentry>
            <stentry>June 21, 2011</stentry>
            <stentry><xref format="html"
                href="http://lists.oasis-open.org/archives/dita/201106/msg00036.html"
                scope="external">Meeting Minutes</xref></stentry>
          </strow>
          <strow>
            <stentry>Stage 2 proposal submitted</stentry>
            <stentry>
              <p>Initial Revision: January 22, 2012</p>
              <p>Final Revision: April 23, 2013</p>
            </stentry>
            <stentry>
              <p>Initial Revision: <xref
                  href="https://www.oasis-open.org/committees/download.php/44886/1-3proposal-13004.htm"
                  scope="external">HTML</xref> (no DITA by accident)</p>
              <p>Final Revision: <xref scope="external"
                  href="https://www.oasis-open.org/committees/download.php/48898/1-3proposal-13004.html"
                  >HTML</xref>, <xref scope="external"
                  href="https://www.oasis-open.org/committees/download.php/48897/1-3proposal-13004.dita"
                  >DITA</xref></p>
            </stentry>
          </strow>
          <strow>
            <stentry>Stage 2 proposal discussed</stentry>
            <stentry>
              <p>January 24, 2012</p>
              <p>April 9, 2013</p>
              <p>April 23, 2013</p>
            </stentry>
            <stentry>
              <p><xref scope="external"
                  href="https://www.oasis-open.org/apps/org/workgroup/dita/download.php/44905/minutes20120124.txt"
                  >January 24, 2012</xref></p>
              <p><xref
                  href="https://www.oasis-open.org/apps/org/workgroup/dita/download.php/48894/minutes20130409.txt"
                  scope="external">April 9, 2013</xref></p>
              <p><xref
                  href="https://www.oasis-open.org/apps/org/workgroup/dita/download.php/49009/minute20130423.txt"
                  scope="external">April 23, 2013</xref></p>
            </stentry>
          </strow>
          <strow>
            <stentry>Stage 2 proposal approved</stentry>
            <stentry>April 30, 2013</stentry>
            <stentry><xref
                href="https://www.oasis-open.org/apps/org/workgroup/dita/download.php/49092/minutes20130430.txt"
                scope="external">Minutes</xref></stentry>
          </strow>
          <strow>
            <stentry>Stage 3 proposal submitted to reviewers</stentry>
            <stentry>July 8, 2013</stentry>
            <stentry>David Helfinstine, Eliot Kimber</stentry>
          </strow>
          <strow>
            <stentry>Stage 3 proposal (this document) submitted</stentry>
            <stentry/>
            <stentry/>
          </strow>
        </simpletable>
      </section>
      <section>
        <title>Approved technical requirements</title>
        <p>Future post DITA 1.2 work from Issue #12007: Item 2: Consider adding a scoping mechanism
          for use with key definitions and possibly other aspects of DITA based on the map hierarchy
          or the combined element hierarchy within a set of maps. Related topic: Consider allowing
          subsequent key definitions within the same map or within peer maps to override previous
          key definitions, probably as part of some hierarchal scope, and probably in a fashion that
          is the same as or similar to override mechanisms to be developed for other features such
          as ditaval.</p>
      </section>
      <section>
        <title>Dependencies or interrelated proposals</title>
        <p>13041, cross-deliverable linking, depends heavily on this proposal.</p>
      </section>
      <section>
        <title>Modified DTDs</title>
        <p>The <codeph>topicref-atts</codeph> entity and its relatives from
              <b><filepath>map.mod</filepath></b> will be modified with the new
            <codeph>@keyscope</codeph> attribute.</p>
        <codeblock>&lt;!ENTITY % topicref-atts 
             "collection-type 
                        (choice | 
                         family | 
                         sequence | 
                         unordered |
                         -dita-use-conref-target) 
                                  #IMPLIED
              type 
                        CDATA 
                                  #IMPLIED
              processing-role
                        (normal |
                         resource-only |
                         -dita-use-conref-target)
                                  #IMPLIED
              scope 
                        (external | 
                         local | 
                         peer | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              locktitle 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              format 
                        CDATA 
                                  #IMPLIED
              linking 
                        (none | 
                         normal | 
                         sourceonly | 
                         targetonly |
                         -dita-use-conref-target) 
                                  #IMPLIED
              toc 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              print 
                        (no | 
                         printonly | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              search 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              chunk 
                        CDATA 
                                  #IMPLIED
<b>              keyscope
                        CDATA
                                  #IMPLIED
</b>  "
>

&lt;!ENTITY % topicref-atts-no-toc 
             'collection-type 
                        (choice | 
                         family | 
                         sequence | 
                         unordered |
                         -dita-use-conref-target) 
                                  #IMPLIED
              type 
                        CDATA 
                                  #IMPLIED
              processing-role
                        (normal |
                         resource-only |
                         -dita-use-conref-target)
                                  #IMPLIED
              scope 
                        (external | 
                         local | 
                         peer | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              locktitle 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              format 
                        CDATA 
                                  #IMPLIED
              linking 
                        (none | 
                         normal | 
                         sourceonly | 
                         targetonly |
                         -dita-use-conref-target) 
                                  #IMPLIED
              toc 
                        (no | 
                         yes | 
                         -dita-use-conref-target)
                                  "no"
              print 
                        (no | 
                         printonly | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              search 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              chunk 
                        CDATA 
                                  #IMPLIED
<b>              keyscope
                        CDATA
                                  #IMPLIED
</b>  '
>

&lt;!ENTITY % topicref-atts-without-format 
             "collection-type 
                        (choice | 
                         family | 
                         sequence | 
                         unordered |
                         -dita-use-conref-target) 
                                  #IMPLIED
              type 
                        CDATA 
                                  #IMPLIED
              processing-role
                        (normal |
                         resource-only |
                         -dita-use-conref-target)
                                  #IMPLIED
              scope 
                        (external | 
                         local | 
                         peer | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              locktitle 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              linking 
                        (none | 
                         normal | 
                         sourceonly | 
                         targetonly |
                         -dita-use-conref-target) 
                                  #IMPLIED
              toc 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              print 
                        (no | 
                         printonly | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              search 
                        (no | 
                         yes | 
                         -dita-use-conref-target) 
                                  #IMPLIED
              chunk 
                        CDATA 
                                  #IMPLIED
<b>              keyscope
                        CDATA
                                  #IMPLIED
</b>  "
>

</codeblock>
        <p><b><filepath>learningDomain.mod</filepath></b></p>
        <codeblock>&lt;!-- Attributes that are common to each topicref specialization in this domain -->
&lt;!ENTITY % learningDomain-topicref-atts-no-chunk
             "navtitle
                        CDATA
                                  #IMPLIED
              href
                        CDATA
                                  #IMPLIED
              keyref
                        CDATA
                                  #IMPLIED
              keys
                        CDATA
                                  #IMPLIED
<b>              keyscope
                        CDATA
                                  #IMPLIED
</b>              query
                        CDATA
                                  #IMPLIED
              copy-to
                        CDATA
                                  #IMPLIED
              outputclass
                        CDATA
                                  #IMPLIED
              scope
                        (external |
                         local | 
                         peer | 
                         -dita-use-conref-target)
                                  #IMPLIED
              processing-role
                        (normal |
                         resource-only |
                         -dita-use-conref-target)
                                  #IMPLIED
              linking
                        (targetonly|
                         sourceonly|
                         normal|
                         none | 
                         -dita-use-conref-target)
                                  #IMPLIED
              locktitle
                        (yes|
                         no | 
                         -dita-use-conref-target)
                                  #IMPLIED
              toc
                        (yes|
                         no | 
                         -dita-use-conref-target)
                                  #IMPLIED
              print
                        (yes|
                         no | 
                         printonly |
                         -dita-use-conref-target)
                                   #IMPLIED
              search
                        (yes|
                         no | 
                         -dita-use-conref-target)
                                   #IMPLIED
              %univ-atts;"
>
</codeblock>
        <p><b><filepath>mapMod.xsd</filepath></b></p>
        <codeblock>  &lt;xs:attributeGroup name="topicref-atts">
    &lt;xs:annotation>
      &lt;xs:documentation>
        The %topicref-atts; parameter entity represents a group of attributes
        used in numerous map elements: map, topicref, relcolspec, relcell, topichead,
        and topicgroup. The set is similar to those documented in &lt;xref href="topicref-atts-no-toc.xml">topicref-atts-no-toc&lt;/xref>
        but includes the &lt;i>&lt;keyword>toc&lt;/keyword>&lt;/i> attribute.
      &lt;/xs:documentation>
    &lt;/xs:annotation>
     &lt;xs:attribute name="collection-type" type="collection-type.class"/>
     &lt;xs:attribute name="type" type="xs:string"/>
    &lt;xs:attribute name="processing-role" type="processing-role-att.class" />
     &lt;xs:attribute name="scope" type="scope-att.class"/>
     &lt;xs:attribute name="locktitle" type="yesno-att.class"/>
     &lt;xs:attribute name="format" type="xs:string"/>
     &lt;xs:attribute name="linking" type="linkingtypes.class"/>
     &lt;xs:attribute name="toc" type="yesno-att.class"/>
     &lt;xs:attribute name="print" type="print-att.class"/>
     &lt;xs:attribute name="search" type="yesno-att.class"/>
     &lt;xs:attribute name="chunk" type="xs:string"/>
<b>     &lt;xs:attribute name="keyscope" type="xs:string"/></b>
  &lt;/xs:attributeGroup>

&lt;!-- ... -->

  &lt;xs:attributeGroup name="topicref-atts-no-toc">
    &lt;xs:annotation>
      &lt;xs:documentation>
        The %topicref-atts-no-toc; parameter entity represents the set
        of attributes used in the 
          &lt;xref href="reltable.xml">reltable&lt;/xref>
         map
        element. The set is similar to those documented in 
          &lt;xref href="topicref-atts.xml">topicref-atts&lt;/xref>
         but
        for &amp;lt;&lt;keyword>reltable&lt;/keyword>&amp;gt; the &lt;i>&lt;keyword>toc&lt;/keyword>&lt;/i> attribute
        defaults to &lt;q>no&lt;/q>. For the other elements that use the %topicref-atts;
        group declaration, the &lt;i>&lt;keyword>toc&lt;/keyword>&lt;/i> attribute doesn't have
        a default; they can inherit their &lt;i>&lt;keyword>toc&lt;/keyword>&lt;/i> value from
        the nearest container, otherwise it functions upon output as if set to &lt;q>yes&lt;/q>.
      &lt;/xs:documentation>
    &lt;/xs:annotation>
    &lt;xs:attribute name="collection-type" type="collection-type.class"/>
     &lt;xs:attribute name="type" type="xs:string"/>
    &lt;xs:attribute name="processing-role" type="processing-role-att.class" />
     &lt;xs:attribute name="scope" type="scope-att.class"/>
     &lt;xs:attribute name="locktitle" type="yesno-att.class"/>
     &lt;xs:attribute name="format" type="xs:string"/>
     &lt;xs:attribute name="linking" type="linkingtypes.class"/>
     &lt;xs:attribute name="toc" type="yesno-att.class" default="no"/>
     &lt;xs:attribute name="print" type="print-att.class"/>
     &lt;xs:attribute name="search" type="yesno-att.class"/>
     &lt;xs:attribute name="chunk" type="xs:string"/>
<b>     &lt;xs:attribute name="keyscope" type="xs:string"/></b>
  &lt;/xs:attributeGroup>
</codeblock>
        <p>Unlike the DTDs, in the schemas, the <codeph>topicref-atts-without-format</codeph>
          attribute group is defined in <b><filepath>mapGroupMod.xsd</filepath></b> instead of
            <filepath>mapMod.xsd</filepath>.</p>
        <codeblock>  &lt;xs:attributeGroup name="topicref-atts-without-format">
    &lt;xs:annotation>
      &lt;xs:documentation>
        The %topicref-atts-without-format; parameter entity represents a group of attributes
        used in numerous map elements: mapref,
        and topicgroup. The set is similar to those documented in &lt;xref href="topicref-atts.xml">topicref-atts&lt;/xref> but
        excludes the &lt;i>&lt;keyword>format&lt;/keyword>&lt;/i> attribute.
      &lt;/xs:documentation>
    &lt;/xs:annotation>
    &lt;xs:attribute name="collection-type" type="collection-type.class"/>
    &lt;xs:attribute name="type" type="xs:string"/>
    &lt;xs:attribute name="processing-role" type="processing-role-att.class" />
    &lt;xs:attribute name="scope" type="scope-att.class"/>
    &lt;xs:attribute name="locktitle" type="yesno-att.class"/>
    &lt;xs:attribute name="linking" type="linkingtypes.class"/>
    &lt;xs:attribute name="toc" type="yesno-att.class"/>
    &lt;xs:attribute name="print" type="print-att.class"/>
    &lt;xs:attribute name="search" type="yesno-att.class"/>
    &lt;xs:attribute name="chunk" type="xs:string"/>
<b>    &lt;xs:attribute name="keyscope" type="xs:string"/></b>
  &lt;/xs:attributeGroup>
  
</codeblock>
        <p><b><filepath>learningDomain.xsd</filepath></b></p>
        <codeblock>    &lt;xs:attributeGroup name="learningDomain-topicref-atts-no-chunk">
          &lt;xs:attribute name="navtitle" type="xs:string"/>  
          &lt;xs:attribute name="href" type="xs:string"/>
          &lt;xs:attribute name="keyref" type="xs:string"/>  
          &lt;xs:attribute name="keys" type="xs:string"/>
<b>          &lt;xs:attribute name="keyscope" type="xs:string"/></b>
          &lt;xs:attribute name="query" type="xs:string"/>
          &lt;xs:attribute name="copy-to" type="xs:string"/>          
          &lt;xs:attribute name="outputclass" type="xs:string"/>    
          &lt;xs:attribute name="scope" type="scope-att.class"/>
          &lt;xs:attribute name="processing-role" type="processing-role-att.class" />
          &lt;xs:attribute name="locktitle" type="yesno-att.class"/>
          &lt;xs:attribute name="linking" type="linkingtypes.class"/>
          &lt;xs:attribute name="toc" type="yesno-att.class"/>
          &lt;xs:attribute name="print" type="print-att.class"/>
          &lt;xs:attribute name="search" type="yesno-att.class"/>
          &lt;xs:attributeGroup ref="univ-atts" />          
    &lt;/xs:attributeGroup>
</codeblock>
      </section>
      <section>
        <title>Modified specification documentation</title>
        <p>Provide a listing of new or modified topics. For existing topics, provide the location of
          the DITA 1.2 topic; for new topics, suggest where you think the topic should be located in
          the TOC.</p>
        <p>List the exact language suggested for the topics. For existing topics, you can use a
          table to compare the DITA 1.2 text and the proposed text for DITA 1.3. For new topics, use
          the templates nested within this topic. </p>
        <table frame="all" id="table_sfk_hxp_sk">
          <title><filepath>dita-terminology.dita</filepath></title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>DITA 1.2 Language</entry>
                <entry>DITA 1.3 Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <dl>
                    <dlentry>
                      <dt>key definition</dt>
                      <dd>A &lt;topicref> element or specialization of a &lt;topicref> element that
                        specifies the @keys attribute and defines one or more key names.</dd>
                    </dlentry>
                    <dlentry>
                      <dt>key resolution context</dt>
                      <dd>The root map that establishes the context for resolving key references.
                        For a given key-resolution instance, there is at most one root map that
                        defines the effective value of the key space, as determined by the key
                        definition precedence rules..</dd>
                    </dlentry>
                    <dlentry>
                      <dt>key space</dt>
                      <dd>The effective set of unique key names that are defined by a given key
                        resolution context. Within a given key resolution context, a key name has at
                        most one binding.</dd>
                    </dlentry>
                  </dl>
                </entry>
                <entry>
                  <dl>
                    <dlentry>
                      <dt>key definition</dt>
                      <dd>A &lt;topicref> element or specialization of a &lt;topicref> element that
                        specifies the @keys attribute and defines one or more key names.</dd>
                    </dlentry>
                    <dlentry rev="13004-proposal">
                      <dt>key scope</dt>
                      <dd>A root map or section of a map hierarchy associated with a unique key
                        space for purposes of key reference resolution.</dd>
                    </dlentry>
                    <dlentry>
                      <dt>key space</dt>
                      <dd rev="13004-proposal">The set of unique key names that are defined for a
                        given key scope. Within a given key scope, a key name has at most one
                        definition, as determined by the key definition precedence rules.</dd>
                    </dlentry>
                    <dlentry>
                      <dt>key resolution context</dt>
                      <dd rev="13004-proposal">The key scope that establishes the context for
                        resolving key references. For a given key-resolution instance, there is at
                        most one key scope that defines the effective key space, which in turn
                        provides the effective key definition.</dd>
                    </dlentry>
                  </dl>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="all" id="table_y3k_2zp_sk">
          <title><filepath>definition-of-ditamaps.dita</filepath></title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>DITA 1.2 Language</entry>
                <entry>DITA 1.3 Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><ph id="shortdesc">DITA maps are documents that organize topics and other
                    resources into structured collections of information. DITA maps specify
                    hierarchy and the relationships among the topics; they also provide the context
                    in which keys are defined and resolved. DITA maps <keyword>should</keyword> have
                      <filepath>.ditamap</filepath> file extensions.</ph></entry>
                <entry><ph>DITA maps are documents that organize topics and other resources into
                    structured collections of information. DITA maps specify hierarchy and the
                    relationships among the topics; they also provide the <ph rev="13004-proposal"
                      >contexts</ph> in which keys are defined and resolved. DITA maps
                      <keyword>should</keyword> have <filepath>.ditamap</filepath> file
                    extensions.</ph><draft-comment author="Chris Nitchie">One-word change: 'context'
                    to 'contexts'</draft-comment></entry>
              </row>
              <row>
                <entry>
                  <p>DITA maps also define keys and provide the context in which key references are
                    resolved. A &lt;topicref> element (or specialized &lt;topicref> such as
                    &lt;keydef>) may be used to define a key which binds that key name to a
                    specified resource.</p>
                </entry>
                <entry>
                  <p>DITA maps also define keys and organize the <ph rev="13004-proposal"
                      >contexts</ph> in which key references are resolved. <ph rev="13004-proposal"
                      >A &lt;topicref> or &lt;map> element, or any specialization, may be used to
                      create a new context for key definition and resolution. A &lt;topicref>
                      element, or specialized &lt;topicref> such as &lt;keydef>, may also be used to
                      define a key which binds that key name to a specified resource for references
                      in the same key scope.</ph></p>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="all" id="table_yc5_gbq_sk">
          <title><filepath>purpose-of-ditamaps.dita</filepath></title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>DITA 1.2 Language</entry>
                <entry>DITA 1.3 Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <dl>
                    <dlentry>
                      <dt>Defining keys</dt>
                      <dd>Maps can define keys, which provide an indirect addressing mechanism that
                        enhances portability of content. The keys are defined by &lt;topicref>
                        elements or specialization of &lt;topicref> elements, such as &lt;keydef>.
                        The &lt;keydef> element is a convenience element; it is a specialized type
                        of a &lt;topicref> element with the following attributes:<ul
                          id="ul_krz_3bq_sk">
                          <li>A required @keys attribute</li>
                          <li>A @processing-role attribute with a default value of
                            "resource-only".</li>
                        </ul></dd>
                      <dd>Maps also are the context for resolving key-based references, such as
                        elements that specify the @keyref or @conkeyref attribute.</dd>
                    </dlentry>
                  </dl>
                </entry>
                <entry>
                  <dl>
                    <dlentry>
                      <dt rev="13004-proposal">Defining keys and key scopes</dt>
                      <dd>Maps can define keys, which provide an indirect addressing mechanism that
                        enhances portability of content. The keys are defined by &lt;topicref>
                        elements or specialization of &lt;topicref> elements, such as &lt;keydef>.
                        The &lt;keydef> element is a convenience element; it is a specialized type
                        of a &lt;topicref> element with the following attributes:<ul
                          id="ul_m24_jbq_sk">
                          <li>A required @keys attribute</li>
                          <li>A @processing-role attribute with a default value of
                            "resource-only".</li>
                        </ul></dd>
                      <dd>Maps also define the context <ph rev="13004-proposal">or contexts</ph> for
                        resolving key-based references, such as elements that specify the @keyref or
                        @conkeyref attribute. <ph rev="13004-proposal">Elements within a map
                          structure that specify a @keyscope attribute create a new context for key
                          reference resolution. Key references within such elements are resolved
                          against the set of effective key definitions for that scope.</ph></dd>
                    </dlentry>
                  </dl>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="all" id="table_fr2_dfq_sk">
          <title><filepath>ditamap-attributes.dita</filepath></title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>DITA 1.2 Language</entry>
                <entry>DITA 1.3 Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <draft-comment author="Chris Nitchie">The keyscope entry will ultimately go next
                    to the entry for keys, which is currently missing from the spec. Reported as a
                    doc fix.</draft-comment>
                </entry>
                <entry>
                  <dl>
                    <dlentry rev="13004-proposal">
                      <dt>keyscope</dt>
                      <dd>Defines a new scope for key definition and resolution, and gives the scope
                        one or more names, separated by white space. Key definitions within a scope
                        can only be addressed directly by key references within the same scope. The
                        key space defined by a key scope also inherits all of the key definitions
                        from its parent scope, and if a key is defined in both the parent and child
                        scopes, the definition from the parent scope takes precedence. Scoped key
                        definitions are also added to the parent scope's key space, prepended by the
                        scope name followed by a period. If a scope has more than one name, then
                        each key within the scope will be contributed to the parent scope once for
                        each prefix.</dd>
                    </dlentry>
                  </dl>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="all" id="table_q5r_4hq_sk">
          <title><filepath>overview_of_keys.dita</filepath></title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>DITA 1.2 Language</entry>
                <entry>DITA 1.3 Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>To use key references, one must understand how keys are defined and bound to
                  resources, how a map hierarchy establishes a key space, and the interaction of
                  keys with conditional processing.</entry>
                <entry>To use key references, one must understand how keys are defined and bound to
                  resources, how a map hierarchy <ph rev="13004-proposal">and key scopes establish
                    key spaces</ph>, and the interaction of keys with conditional
                  processing.</entry>
              </row>
              <row>
                <entry><i>New section: Key scopes</i></entry>
                <entry rev="13004-proposal">
                  <p><b>Key scopes</b></p>
                  <p>A key scope defines a key space associated with a segment of the map hierarchy,
                    the contents of which are described below. It also defineds a key reference
                    resolution context for key references occurring within the scope-defining
                    element, associated with that key space. That is, key references within a key
                    scope are resolved against the key space associated with that key scope.</p>
                  <p>A key scope is declared by setting the @keyscope attribute on a &lt;map>,
                    &lt;topicref>, or any specialization of &lt;map> or &lt;topicref>, within the
                    map structure. The value of the @keyscope attribute is the whitespace-delimited
                    list of names for the key scope. The legal characters for a key scope name are
                    the same as those for keys.</p>
                  <note>
                    <p>If the @keyscope attribute is specified both on a map element and on a
                      ltopicref element referencing that map, only one new scope is introduced, not
                      two. If the topicref has a scope of "local", the set of names for the
                      resulting key scope is the union of the unique values of the two @keyscope
                      attributes. If the topicref has a scope of "peer", only the scope names on the
                      topicref apply, because there may be cases where the referenced map is
                      unavailable.</p>
                  </note>
                  <p>The key space associated with a key scope consists of the following, in order
                    of precedence:</p>
                  <ol id="ol_lhk_kbs_tk">
                    <li>All keys in the parent key scope's key space, if any.</li>
                    <li>All keys defined within the scope-defining element, including that element
                      itself and any directly addressed, local scope maps contained by the
                      scope-defining element, but <i>excluding</i> keys defined in other key scopes
                      contained by the scope-defining element (i.e. child scopes).</li>
                    <li>Keys defined in child scopes, prefixed with the name of the key scope,
                      followed by a period. If a child key scope has multiple names, then each of
                      its keys is addressable from the parent key scope using any of the child key
                      scope's names as a prefix.</li>
                  </ol>
                  <note>Since a parent scope contains the scope-qualified keys from its child
                    scopes, and a child key scope inherits all key definitions from its parent
                    scope, a child scope also contains all of the qualified key names from itself,
                    as well as its "sibling" scopes. <ph rev="October">See <xref
                        href="#findingKeyDefinitionsFromScopes"/> for an example of
                    this.</ph></note>
                  <p>For purposes of key definition precedence within a scope, the implicit
                    qualified key definitions a parent key scope derives from a child key scope are
                    considered to occur at the location of the child scope-defining element.</p>
                  <p>The root element in the root map in a map hierarchy always necessarily defines
                    a key scope, even if its @keyscope attribute is unspecified.</p>
                </entry>
              </row>
              <row>
                <entry>
                  <p><b>Key spaces</b></p>
                  <p>A root map and its directly addressed, local scope descendant maps establish a
                    unique key space within which each unique key name has exactly one binding to a
                    set of resources.</p>
                  <p>For the purposes of determining the effective key definitions for the key space
                    represented by a given root map, a map tree is determined by considering only
                    directly addressed, local scope maps descending from the root map. The order of
                    subordinate maps is determined by the document order of the topicrefs that point
                    to them. Indirect references to maps with key references are necessarily ignored
                    until after the key space is determined.</p>
                  <p>Maps addressed by &lt;navref> do not contribute to the key space of a map tree.
                    Maps referenced by &lt;navref> are equivalent to maps referenced with a scope of
                    "peer" or "external" and therefore need not be present or available at the time
                    the referencing map is processed for purposes of key space construction.</p>
                </entry>
                <entry>
                  <p><b>Key spaces</b></p>
                  <p><ph rev="13004-proposal">A key scope-defining element and its directly
                      addressed, local scope descendant maps</ph> establish a unique key space
                    within which each unique key name has exactly one binding to a set of
                    resources.</p>
                  <p>For the purposes of determining the effective key definitions for the key space
                    represented by a given <ph rev="13004-proposal">key scope</ph>, a map tree is
                    determined by considering only directly addressed, local scope maps descending
                    from the<ph rev="13004-proposal"> key scope-defining element</ph>. The order of
                    subordinate maps is determined by the document order of the topicrefs that point
                    to them. Indirect references to maps with key references are necessarily ignored
                    until after the key space is determined.</p>
                  <p>Maps addressed by &lt;navref> do not contribute to the key space of a <ph
                      rev="13004-proposal">key scope</ph>. Maps referenced by &lt;navref> are
                    equivalent to maps referenced with a scope of "peer" or "external" and therefore
                    need not be present or available at the time the referencing map is processed
                    for purposes of key space construction.</p>
                </entry>
              </row>
              <row>
                <entry>
                  <p><b>Effective key definitions</b></p>
                  <p>For a given key there is at most one effective definition within a key space. A
                    key definition is the effective definition for a given key if it is the first,
                    in document order, within the map document that contains it, and is the first in
                    the map tree in breadth-first order. It is not an error for the same key name to
                    be defined more than once within a map or map tree, and duplicate key
                    definitions <keyword>should</keyword> be ignored without warning. </p>
                  <note>A given &lt;topicref> element that defines more than one key may be the
                    effective definition for some of its keys but not for others. It is the
                    duplicate binding of a key name to its definition that is ignored, not the
                    key-defining topic reference as a whole.</note>
                  <p>Key definitions are not scoped by the map document within which they occur or
                    by the element hierarchy of their containing map document. Keys do not have to
                    be declared before they are referenced. The key space is effective for the
                    entire document, so the order of key definitions and key references relative to
                    one another within the map hierarchy is not significant, and keys defined in any
                    map in the map tree are available for use with key references from all maps and
                    topics processed in the context of the root map. </p>
                  <note>These rules mean that key definitions higher in the map tree hierarchy take
                    precedence over key definitions lower in the map tree and that key definitions
                    in referencing maps always take precedence over key definitions in referenced
                    maps. These rules also mean that the entire key space must be determined before
                    any keys can be resolved to their ultimately-addressed resources (if
                    any).</note>
                  <note>Because keys are defined in maps, all key-based processing must be done in
                    the context of a root map that establishes the effective key space. </note>
                  <!--<p>Topicrefs that address subordinate maps that use @keyref  without
a fallback           @href value or that use @conkeyref without
a fallback           @conref value do not contribute
to the map tree for the purpose of         determining the key space.
The maps ultimately referenced by such topicrefs will contribute 
       to the map tree but only at the locations where those maps
are directly addressed. This         means that such maps may occur
in the map tree in a different position than they would if       
 the key-based address was a direct address. </p>-->
                  <!--Above needs clarification. The following is the proposed replacement.-->
                  <p>For key definitions in a submap to be included in the key space, there must be
                    a direct URI reference to that submap from another directly addressed map in the
                    map tree. However, if that same submap is referenced indirectly and has no
                    direct URI reference as a backup (using @keyref without providing a fallback
                    @href value, or using @conkeyref without providing a fallback @conref value),
                    that reference is ignored for purposes of constructing the key space, and the
                    definitions in that submap consequently do not enter into the construction of
                    the key space at that point.</p>
                </entry>
                <entry>
                  <p><b>Effective key definitions</b></p>
                  <p>For a given key there is at most one effective definition within a key space. A
                    key definition is the effective definition for a given key if it is the first,
                    in document order, within the <ph rev="13004-proposal">key scope-defining
                      element</ph> that contains it, and is the first in the map tree <ph
                      rev="13004-proposal">beneath the scope-defining elemnt</ph> in breadth-first
                    order. It is not an error for the same key name to be defined more than once
                    within a map or <ph rev="13004-proposal">key scope</ph>, and duplicate key
                    definitions <keyword>should</keyword> be ignored without warning. </p>
                  <note>A given &lt;topicref> element that defines more than one key may be the
                    effective definition for some of its keys but not for others. It is the
                    duplicate binding of a key name to its definition that is ignored, not the
                    key-defining topic reference as a whole.</note>
                  <p><ph rev="13004-proposal">Key definitions are scoped by the key scope-defining
                      elements within which they occur.</ph> Keys do not have to be declared before
                    they are referenced. The key space is effective for the entire <ph
                      rev="13004-proposal">key scope</ph>, so the order of key definitions and key
                    references relative to one another within the <ph rev="13004-proposal">hierarchy
                      of a key scope</ph> is not significant, and keys defined in any map in the <ph
                      rev="13004-proposal">key scope</ph> are available for use with key references
                    from all maps and topics processed in the context of the <ph
                      rev="13004-proposal">key scope</ph>. </p>
                  <note>These rules mean that key definitions higher in the map tree hierarchy take
                    precedence over key definitions lower in the map tree and that key definitions
                    in referencing maps always take precedence over key definitions in referenced
                    maps. These rules also mean that all key spaces must be fully determined before
                    any keys can be resolved to their ultimately-addressed resources (if
                    any).</note>
                  <note>Because keys are defined in maps, all key-based processing must be done in
                    the context of a root map that establishes the <ph rev="13004-proposal">root key
                      scope and scope hierarchy, or a specific scope within such a map.</ph></note>
                  <p>For key definitions in a submap to be included in the key space, there must be
                    a direct URI reference to that submap from another directly addressed map in the
                    map tree. However, if that same submap is referenced indirectly and has no
                    direct URI reference as a backup (using @keyref without providing a fallback
                    @href value, or using @conkeyref without providing a fallback @conref value),
                    that reference is ignored for purposes of constructing the key space, and the
                    definitions in that submap consequently do not enter into the construction of
                    the key space at that point.</p>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="all" id="table_dbf_dbt_tk">
          <title><filepath>commonLRdefs.dita</filepath></title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>DITA 1.2 Language</entry>
                <entry>DITA 1.3 Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>topicref-atts attribute group (collection-type, processing-role, type, scope,
                  locktitle, format, linking, toc, print, search, chunk)</entry>
                <entry>topicref-atts attribute group (collection-type, processing-role, type, scope,
                  locktitle, format, linking, toc, print, search, chunk, keyscope)</entry>
              </row>
              <row>
                <entry>topicref-atts-no-toc attribute group (collection-type, processing-role, type,
                  scope, locktitle, format, linking, toc, print, search, chunk)</entry>
                <entry>topicref-atts-no-toc attribute group (collection-type, processing-role, type,
                  scope, locktitle, format, linking, toc, print, search, chunk, keyscope)</entry>
              </row>
              <row>
                <entry>topicref-atts-without-format attribute group (collection-type,
                  processing-role, type, scope, locktitle, linking, toc, print, search,
                  chunk)</entry>
                <entry>topicref-atts-without-format attribute group (collection-type,
                  processing-role, type, scope, locktitle, linking, toc, print, search, chunk,
                  keyscope)</entry>
              </row>
              <row>
                <entry><i>New attribute table entry for 'keyscope', to be referenced from
                    topicref-atts.dita</i></entry>
                <entry rev="13004-proposal">Specifies that the element marks the boundaries of a key
                  scope. See <xref href="#the_keyscope_attribute" format="dita"/> for details on how
                  to use the keyscope attribute.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <table frame="all" id="table_ynj_ndt_tk">
          <title><filepath>thekeysattribute.dita</filepath></title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>DITA 1.2 Language</entry>
                <entry>DITA 1.3 Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>A keys attribute consists of one or more space-separated keys. Map authors
                  define keys using a topicref or topicref specialization that contains the “keys”
                  attribute. Each key definition introduces a global identifier for a resource
                  referenced from a map. Keys resolve to the resources given as the href value on
                  the key definition topicref element, to content contained within the key
                  definition topicref element, or both.</entry>
                <entry>A keys attribute consists of one or more space-separated keys. Map authors
                  define keys using a topicref or topicref specialization that contains the “keys”
                  attribute. Each key definition introduces an identifier for a resource referenced
                  from the map. Keys resolve to the resources given as the href value on the key
                  definition topicref element, to content contained within the key definition
                  topicref element, or both.<draft-comment author="Chris Nitchie">One-word change:
                    removed the word 'global' from, 'Each key definition introduces a global
                    identifier...'.</draft-comment></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </body>
    <concept id="findingKeyDefinitionsFromScopes" rev="October">
      <title>Finding Effective Key Definitions for a Key Scope</title>
      <shortdesc>When searching for the effective definition for a given key name from within a
        scope, check each scope between the root scope and the referencing scope, inclusive,
        starting from the root. The first matching definition - including implicit scope-qualified
        key names contribued by child key scopes - should be used to resolve the
        reference.</shortdesc>
      <conbody>
        <section rev="October">
          <p>Consider the following map:</p>
          <codeblock>&lt;map>
  &lt;title>Root Map&lt;/title>
  
  &lt;keydef keys="a"/>
  
  &lt;topicgroup keyscope="A">
    &lt;keydef keys="b"/>
    
    &lt;topicgroup keyscope="A-1">
      &lt;keydef keys="c"/>
    &lt;/topicgroup>
    
    &lt;topicgroup keyscope="A-2">
      &lt;keydef keys="d"/>
    &lt;/topicgroup>
  &lt;/topicgroup> &lt;!-- End scope A -->
  
  &lt;topicgroup keyscope="B">
    &lt;keydef keys="a"/>
    &lt;keydef keys="e"/>
    
    &lt;topicgroup keyscope="B-1">
      &lt;keydef keys="f"/>
    &lt;/topicgroup>
    
    &lt;topicgroup keyscope="B-2">
      &lt;keydef keys="g"/>
    &lt;/topicgroup>
  &lt;/topicgroup> &lt;!-- End scope B -->
&lt;/map></codeblock>
          <p>The key scopes in this map form a tree structure.</p>
          <fig>
            <title>Sample Key Scope Structure</title>
            <image id="image_jkb_x21_wl"
              href="https://www.oasis-open.org/committees/download.php/51086/Keyscopes-Illustrated.png"
            />
          </fig>
          <ul id="ul_xft_mg1_wl">
            <li>Explicit key definitions are shown undecorated.</li>
            <li>Implicit qualified key names contributed by child scopes are shown in
              parentheses.</li>
            <li>Keys overridden by their parent scopes are in square brackets.</li>
            <li>The arrows denote parentage of each scope.</li>
          </ul>
          <p>Here are some examples of various potential key references in various scopes from the
            above example.</p>
          <ul id="ul_cjp_2j1_wl">
            <li><b>Within Scope A-2</b><ul id="ul_mxs_fj1_wl">
                <li><codeph>keyref="a"</codeph> resolves to the definition for "a" at the root
                  scope.</li>
                <li><codeph>keyref="d"</codeph> resolves to the local definition.</li>
                <li><codeph>keyref="A-2.d"</codeph> also resolves to the local definition, because
                  that qualified key name is available in the parent scope.</li>
                <li><codeph>keyref="c"</codeph> does not resolve, because no definition for that key
                  exists in any of the ancestor scopes.</li>
                <li>However, <codeph>keyref="A-1.c"</codeph> does resolve, because that definition
                  is available in the parent scope.</li>
                <li>As does <codeph>keyref="A.A-1.c"</codeph>, because that definition is available
                  at the root scope.</li>
                <li>This scope can also reference key definitions within the "B" scope descending
                  from the root, such as <codeph>keyref="B.e"</codeph> or
                    <codeph>keyref="B.B-2.g"</codeph>, due to the presence of implicit qualified
                  names for those keys at the root scope.</li>
              </ul></li>
            <li><b>Within Scope B</b><ul id="ul_s25_wj1_wl">
                <li><codeph>keyref="e"</codeph> resolves to the local definition.</li>
                <li><codeph>keyref="a"</codeph> resolves to the <i>root-level</i> definition of "a",
                    <i>not</i> the local definition. Keys from the parent scope override any local
                  definitions.</li>
                <li>However, <codeph>keyref="B.a"</codeph> resolves to the <i>local</i> definition
                  of "a", as inherited from the root scope.</li>
                <li><codeph>keyref="g"</codeph> does not resolve, because no definition for that key
                  exists in this or any parent scope.</li>
                <li>However, <codeph>keyref="B-2.g"</codeph> will resolve due to the availablity of
                  the implicit qualified definition in the current scope.</li>
              </ul></li>
          </ul>
        </section>
      </conbody>
    </concept>
    <concept id="concept_w12_3ts_tk">
      <title>Examples of keys</title>
      <conbody>
        <draft-comment author="Chris Nitchie">This topic already exists. However, since the changes
          to this topic are strictly additive - new sections with new examples - I've written up the
          new sections here instead of using the tabular format normally used for updates to
          existing topics.</draft-comment>
        <section rev="13004-proposal">
          <title>Topic reuse with varying key behavior</title>
          <p>In this example, the “oil change” procedures for Tractor X and Tractor Y are similar
            enough to reuse the same topic for both, but the name of the product is included in the
            title via <codeph>keyref</codeph>. In the map below, the topic
              <filepath>common/oilchange.dita</filepath> is referenced twice. Each reference is
            wrapped within a <codeph>topicgroup</codeph> that defines a key scope, and each scope
            has its own definition of the <codeph>ProductName</codeph> key.</p>
          <codeblock>&lt;map xml:lang="en">
  &lt;title>Equipment Oil Change Procedures&lt;/title>

  &lt;topicgroup keyscope="Tractor-X">
    &lt;keydef keys="ProductName">
      &lt;topicmeta>
        &lt;linktext>Tractor X&lt;/linktext>
      &lt;/topicmeta>
    &lt;/keydef>
    &lt;topicref href="common/oilchange.dita"/>
  &lt;/topicgroup>

  &lt;topicgroup keyscope="Tractor-Y">
    &lt;keydef keys="ProductName">
      &lt;topicmeta>
        &lt;linktext>Tractor Y&lt;/linktext>
      &lt;/topicmeta>
    &lt;/keydef>
    &lt;topicref href="common/oilchange.dita"/>
  &lt;/topicgroup>

&lt;/map></codeblock>
          <codeblock>&lt;task id="oilchange" xml:lang="en">
  &lt;title>Changing the Oil on the &lt;ph keyref="ProductName"/>&lt;/title>
  &lt;!-- etc. -->
&lt;/task></codeblock>
        </section>
        <section rev="13004-proposal">
          <title>Combination of standalone maps with their own key spaces</title>
          <codeblock>&lt;map xml:lang="en">
  &lt;title>Training Courses&lt;/title>
  &lt;mapref href="course-1.ditamap" keyscope="course-1"/>
  &lt;mapref href="course-2.ditamap" keyscope="course-2"/>
  &lt;mapref href="course-3.ditamap" keyscope="course-3"/>
  &lt;topicref keys="summary" href="omnibus-summary.dita"/>
&lt;/map></codeblock>
          <p>This map combines three standalone maps, each with its own set of keys. Each of the
              <codeph>mapref</codeph> elements is marked with a <codeph>keyscope</codeph> attribute,
            meaning that the key definitions within the referenced maps will be confined to those
            sub-structures.</p>
          <p>Since the <codeph>summary</codeph> key is defined in this map as part of the implicit
            root scope, and keys defined in parent scopes override those in child scopes, its
            definition overrides any conflicting definition of <codeph>summary</codeph> in any of
            the referenced maps.</p>
        </section>
        <section rev="13004-proposal">
          <title>Examples of scope-qualified key references</title>
          <codeblock>&lt;map xml:lang="en">
  &lt;title>Scoped Key Example&lt;/title>
  &lt;topicgroup <b>keyscope="scope-1"</b>>
    <b>&lt;keydef keys="key-1" href="topic-1.dita" /></b>

    &lt;!-- This topicref will refer to topic-1.dita.
         This key is defined in this scope. -->
    &lt;topicref keyref="key-1" />

    &lt;!-- This topicref will also refer to topic-1.dita.
         This key is inherited from the root scope. -->
    &lt;topicref keyref="scope-1.key-1" />

    &lt;!-- This topicref will refer to topic-2.dita.
         This key is inherited from the root scope. -->
    &lt;topicref keyref="scope-2.key-1" />
  &lt;/topicgroup>

  &lt;topicgroup <b>keyscope="scope-2"</b>>
    <b>&lt;keydef keys="key-1" href="topic-2.dita" /></b>

    &lt;!-- This topicref will refer to topic-2.dita.
         This key is defined in this scope. -->
    &lt;topicref keyref="key-1" />

    &lt;!-- This topicref will refer to topic-1.dita.
         This key is inherited from the root scope. -->
    &lt;topicref keyref="scope-1.key-1" />

    &lt;!-- This topicref will refer to topic-2.dita.
         This key is inherited from the root scope. -->
    &lt;topicref keyref="scope-2.key-1" />
  &lt;/topicgroup>

  &lt;!-- This topicref will result in an error, because
       no key definition 'key-1' exists at this scope. -->
  &lt;topicref keyref="key-1" />

  &lt;!-- This topicref will refer to topic-1.dita.
       Keys defined in a scope become a part of the
       parent scope, prefixed with the scope name and
       a period. -->
  &lt;topicref keyref="scope-1.key-1" />

  &lt;!-- This topicref will refer to topic-2.dita. -->
  &lt;topicref keyref="scope-2.key-1" />

&lt;/map></codeblock>
          <p>This example illustrates the way keys defined within a key scope can be addressed from
            key references outside that scope.</p>
        </section>
      </conbody>
    </concept>
    <concept id="the_keyscope_attribute" rev="13004-proposal">
      <title>The keyscope attribute</title>
      <shortdesc>The keyscope attribute consists of one or more space-separated key scope names. Map
        authors define the boundaries for key scopes by specifying the keyscope attribute on map
        elements, topicref elements, or elements that are specializations of map or topicref. Such
        elements, their contents, and any locally-scoped content referenced from within the element,
        are considered to be part of the scope. Keys defined within a scope are only directly
        referenceable from within the same scope. They can be referenced from the parent scope using
        the scope's name, followed by a period, followed by the key name.</shortdesc>
      <conbody>
        <note rev="October">Within a given root map, two distinct key scopes with the same name have
          no relationship with each other aside from that implied by their relative locations in the
          key scope hierarchy. They do not, for example, share key definitions. There is no such
          thing as a non-contiguous key scope. The only processing impact of a key scope's names is
          in defining the prefixes used when contributing qualified key names to the parent
          scope.</note>
      </conbody>
      <related-links>
        <link href="#topic_aqh_5zt_3h">
          <linktext>Key-based addressing</linktext>
        </link>
        <link href="#findingKeyDefinitionsFromScopes">
          <linktext>Finding Effective Key Definitions for a Key Scope</linktext>
        </link>
      </related-links>
    </concept>
  </topic>
</dita>
